# Vocabulary Types

## `std::optional`

`optional<T>`是一个模板类，语义上来说，`optional`代表一个“也许有效”、“可选”的对象，语法上来看，一个`optional`对象在有效的状态下表现像一个指针。

* 我们可以直接使用`std::nullopt`来对`std::optional<T>`对象赋值，来表示一个无效对象。
* 我们可以直接用`T`来构造`std::optional<T>`，表示一个有效的对象，支持移动。
* `std::optional<T>`可以直接放在`if`语句里转换为布尔类型。
* 当`std::optional<T>`为有效对象时，我们直接把它当成一个`T*`来使用即可。

如果我们使用`std::optional<T>`来作为返回值，处理一些程序错误时，缺点就是无法进一步的返回更多错误的原因信息，因为只能使用`std::nullopt`。

## `std::variant`

`variant`可以看成c语言中`union`的替代，它更好用的原因在于，我们可以随时通过`index`接口查询当前`variant`对象中存储的是哪一个类型的值。更重要的是，它可以安全的析构。

`std::variant`的缺点是，如果我使用其中的对象，必须显式的使用`get`来获取。

## `std::any`

`std::any`是一个对象，非模板，它可以存储任何类型，当它没有存储任何对象或被`reset`后，它处于一个无效状态，我们可以通过`has_value()`成员函数，来检查它是拥有值。

可以通过`type()`来返回它拥有的值的信息，然后通过`std::any_cast<T>(a)`来从其中获取到类型`T`的对象，如果它拥用的不是`T`类型的对象，则会抛出异常。

我们可以使用`std::any_cast<T>(&a)`来获取一个`T`对象的指针。